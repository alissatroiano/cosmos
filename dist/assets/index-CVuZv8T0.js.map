{"version":3,"file":"index-CVuZv8T0.js","sources":["../../src/script.js"],"sourcesContent":["window.focus(); // Capture keys right away (by default focus is on editor)\r\n\r\n// Create Scene\r\nconst scene = new THREE.Scene();\r\nscene.background = new THREE.Color(0x0a0a0a); // Black background for space\r\n\r\n// Camera setup\r\nconst aspectRatio = window.innerWidth / window.innerHeight;\r\nconst cameraWidth = 960;\r\nconst cameraHeight = cameraWidth / aspectRatio;\r\n\r\nconst camera = new THREE.OrthographicCamera(\r\n    cameraWidth / -2,\r\n    cameraWidth / 2,\r\n    cameraHeight / 2,\r\n    cameraHeight / -2,\r\n    50,\r\n    700\r\n);\r\ncamera.position.set(0, -210, 300);\r\ncamera.lookAt(0, 0, 0);\r\n\r\n// Renderer setup\r\nconst renderer = new THREE.WebGLRenderer();\r\nrenderer.setSize(window.innerWidth, window.innerHeight);\r\nrenderer.shadowMap.enabled = true;\r\ndocument.body.appendChild(renderer.domElement);\r\n\r\n// Lighting\r\nconst ambientLight = new THREE.AmbientLight(0x757575);\r\nscene.add(ambientLight);\r\n\r\nconst dirLight = new THREE.DirectionalLight(0xffffff, 0.6);\r\ndirLight.position.set(100, -100, 100).normalize();\r\ndirLight.castShadow = true;\r\nscene.add(dirLight);\r\n\r\n// Create a planet\r\nfunction createPlanet(color = [], radius = 25) {\r\n    const geometry = new THREE.SphereGeometry(radius, 25, 25);\r\n    const material = new THREE.MeshPhongMaterial({\r\n        color: color,\r\n        shininess: 30\r\n    });\r\n    const sphere = new THREE.Mesh(geometry, material);\r\n    sphere.castShadow = true;\r\n    sphere.receiveShadow = true;\r\n    sphere.position.set(0, 0, 0);\r\n    sphere.renderOrder = 1;\r\n    return sphere;\r\n}\r\n\r\nconst enemyColors = [\r\n    0xfcba03, // Yellow\r\n    0xf22e62, // Pink\r\n    0x8c2b3d, // Red\r\n    0xf6ff33, // yellow\r\n    0x3db32b, // lime green\r\n    0xc94779, // pink\r\n    0xeb3f3f, // salmon red\r\n    0xff8800, // Orange\r\n    0x3babd4, // Blue\r\n    0xf70fc9 // Neon Pink\r\n]\r\n\r\n// Create player planet\r\nconst playerPlanet = createPlanet(0x732bb3);\r\n// Create enemy planet and use ememyColors array to shuffle planet colors\r\nlet enemyPlanet = createPlanet(enemyColors[Math.floor(Math.random() * enemyColors.length)]);\r\n\r\nscene.add(playerPlanet);\r\nscene.add(enemyPlanet);\r\n\r\n// Create a function for a custom orbit track shape\r\nfunction createOrbitTrack(trackRadius, color, centerX, centerZ) {\r\n    const outlineGeometry = new THREE.BufferGeometry();\r\n    const points = [];\r\n    const segments = 64;\r\n\r\n    for (let i = 0; i <= segments; i++) {\r\n        const theta = (i / segments) * Math.PI * 2;\r\n        points.push(\r\n            Math.cos(theta) * trackRadius + centerX,\r\n            0,\r\n            Math.sin(theta) * trackRadius + centerZ\r\n        );\r\n    }\r\n\r\n    outlineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));\r\n    const outlineMaterial = new THREE.LineDashedMaterial({\r\n        color: color,\r\n        dashSize: 10,\r\n        gapSize: 15,\r\n    });\r\n\r\n    const outline = new THREE.LineLoop(outlineGeometry, outlineMaterial);\r\n    outline.computeLineDistances(); // Enable dashed line effect\r\n    return outline;\r\n}\r\n\r\n// Calculate offset for second track\r\nvar angle = 360 * (Math.PI / 180);\r\n\r\nconst offsetDistance = 280; // Distance to offset the second track\r\nconst offsetX = Math.cos(angle) * offsetDistance;\r\nconst offsetZ = Math.sin(angle) * offsetDistance;\r\n\r\nconst centerAdjustX = -offsetX / 2;\r\nconst centerAdjustZ = -offsetZ / 2;\r\n// Create two tracks\r\nconst track1 = createOrbitTrack(280, 0x32a852, centerAdjustX, centerAdjustZ); // First track\r\nconst track2 = createOrbitTrack(280, 0x825a5a, offsetX + centerAdjustX, offsetZ + centerAdjustZ); // Second track\r\n\r\n// Add both tracks to the scene\r\nscene.add(track1);\r\nscene.add(track2);\r\n\r\n// Game state\r\nconst gameState = {\r\n    started: false,\r\n    lastTimestamp: null,\r\n    playerAngleMoved: 0,\r\n    playerAngleInitial: 0,\r\n    score: 0,\r\n    lapsCompleted: 0,\r\n    otherPlanets: [],\r\n    controls: {\r\n        accelerate: false,\r\n        decelerate: false\r\n    }\r\n};\r\n\r\ngameState.otherPlanets.push({\r\n    mesh: enemyPlanet,\r\n    angle: Math.PI,\r\n    speed: 0.025,\r\n    radius: 260, // Adjust as needed\r\n    clockwise: true\r\n});\r\n\r\n// Setup game settings\r\nlet gameOver = false;\r\nlet playerAngle = 0;\r\nlet enemyAngle = Math.PI; // Start moving enemy planet on opposite side\r\nlet newEnemyAngle = Math.PI;\r\nlet velocity = 0.025; // Initial speed for the player\r\nconst maxSpeed = 0.0425; // Maximum speed\r\nconst minimumSpeed = 0.01245;\r\nconst decelerationRate = 0.0125; // Deceleration rate per second\r\nlet lastUpdateTime = performance.now();\r\n\r\n// Player scores 1 point every time they go around the track\r\nfunction scorePoint() {\r\n    gameState.score += 1;\r\n    document.getElementById('score').innerText = gameState.score;\r\n    // log score in console\r\n    console.log('Score: ' + gameState.score);\r\n}\r\n\r\n// Collision detection function\r\nfunction checkCollision(planet1, planet2) {\r\n    const distance = planet1.position.distanceTo(planet2.position);\r\n    return distance < 50; // Adjust this value based on planet sizes\r\n}\r\n\r\n// Track the number of player loops\r\nlet loopCount = 0;\r\n\r\nfunction animate() {\r\n    if (gameOver) return;\r\n    requestAnimationFrame(animate);\r\n\r\n    const currentTime = performance.now();\r\n    const deltaTime = (currentTime - lastUpdateTime) / 1000; // Time in seconds since the last frame\r\n    lastUpdateTime = currentTime;\r\n\r\n    // Apply deceleration to player velocity\r\n    if (velocity > 0) {\r\n        velocity = Math.max(velocity - decelerationRate * deltaTime, 0);\r\n    } else if (velocity < 0) {\r\n        velocity = Math.min(velocity + decelerationRate * deltaTime, 0);\r\n    }\r\n\r\n    // Define a unified track radius for circular paths\r\n    const trackRadius = 280;\r\n\r\n    // Move player planet based on velocity\r\n    playerAngle += velocity;\r\n    playerPlanet.position.x = Math.cos(playerAngle) * trackRadius + centerAdjustX;\r\n    playerPlanet.position.z = Math.sin(playerAngle) * trackRadius + centerAdjustZ;\r\n\r\n    // move player planet at regular velocity if no acceleration or deceleration\r\n    if (velocity === 0) {\r\n        playerAngle += minimumSpeed;\r\n        playerPlanet.position.x = Math.cos(playerAngle) * trackRadius + centerAdjustX;\r\n        playerPlanet.position.z = Math.sin(playerAngle) * trackRadius + centerAdjustZ;\r\n    }\r\n    // Track player loops and spawn enemy planets every 3 loops\r\n    if (playerAngle >= Math.PI * 2) {\r\n        playerAngle -= Math.PI * 2; // Reset angle after each loop\r\n        loopCount++;\r\n        // Score point after every 3 loops\r\n        if (loopCount % 3 === 0) {\r\n            scorePoint();\r\n        }\r\n\r\n        // Spawn a new enemy planet every 3 loops\r\n        if (loopCount % 3 === 0) {\r\n            const randomColor = enemyColors[Math.floor(Math.random() * enemyColors.length)];\r\n            const randomAngle = Math.random() * Math.PI * 2; // Random spawn angle\r\n            const randomSpeed = 0.02 + Math.random() * 0.02; // Random speed between 0.02 and 0.05\r\n\r\n            const newEnemyPlanet = createPlanet(randomColor, Math.random() * 20 + 10); // Random radius\r\n            newEnemyPlanet.position.x = Math.cos(randomAngle) * trackRadius + (offsetX + centerAdjustX);\r\n            newEnemyPlanet.position.z = Math.sin(randomAngle) * trackRadius + (offsetZ + centerAdjustZ);\r\n\r\n            scene.add(newEnemyPlanet);\r\n\r\n            // Add enemy planet to game state with unified direction\r\n            gameState.otherPlanets.push({\r\n                mesh: newEnemyPlanet,\r\n                angle: randomAngle,\r\n                speed: randomSpeed,\r\n                clockwise: false, // Unified direction\r\n            });\r\n        }\r\n    }\r\n\r\n    // Move enemy planets along track\r\n    gameState.otherPlanets.forEach((enemyPlanet) => {\r\n        enemyPlanet.angle += enemyPlanet.speed * (enemyPlanet.clockwise ? 1 : 1);\r\n        enemyPlanet.mesh.position.x = Math.cos(enemyPlanet.angle) * trackRadius + (offsetX + centerAdjustX);\r\n        enemyPlanet.mesh.position.z = Math.sin(enemyPlanet.angle) * trackRadius + (offsetZ + centerAdjustZ);\r\n\r\n        // Check for collisions with the player planet\r\n        if (checkCollision(playerPlanet, enemyPlanet.mesh)) {\r\n            gameOver = true;\r\n            alert(\r\n                `Game Over! Planets collided! Your score: ${gameState.score}. Press R or click the reload button to play again!`\r\n            );\r\n            return;\r\n        }\r\n    });\r\n\r\n    renderer.render(scene, camera);\r\n}\r\n\r\n// Add some stars\r\nfunction addStars() {\r\n    const starsGeometry = new THREE.BufferGeometry();\r\n    const starsMaterial = new THREE.PointsMaterial({\r\n        color: 0xFAFAFA,\r\n        size: 1,\r\n        sizeAttenuation: false\r\n    });\r\n\r\n    const starsVertices = [];\r\n    for (let i = 0; i < 1000; i++) {\r\n        const x = (Math.random() - 0.5) * 2000;\r\n        const y = (Math.random() - 0.5) * 2000;\r\n        const z = (Math.random() - 0.5) * 2000;\r\n        starsVertices.push(x, y, z);\r\n    }\r\n\r\n    starsGeometry.setAttribute('position',\r\n        new THREE.Float32BufferAttribute(starsVertices, 3));\r\n\r\n    const stars = new THREE.Points(starsGeometry, starsMaterial);\r\n    scene.add(stars);\r\n}\r\naddStars();\r\n\r\n// Handle window resize\r\nwindow.addEventListener('resize', () => {\r\n    const newAspectRatio = window.innerWidth / window.innerHeight;\r\n    const newCameraHeight = cameraWidth / newAspectRatio;\r\n\r\n    camera.top = newCameraHeight / 2;\r\n    camera.bottom = -newCameraHeight / 2;\r\n    camera.updateProjectionMatrix();\r\n\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n});\r\n\r\n// Bind acceleration to arrow up button for mobile & tablet\r\ndocument.getElementById('accelerate').addEventListener('click', () => {\r\n    velocity = Math.min(velocity + 0.01, maxSpeed); // Speed up, capped at maxSpeed\r\n});\r\n\r\n// Bind deceleration to arrow down for mobile & tablet\r\ndocument.getElementById('decelerate').addEventListener('click', () => {\r\n    velocity = minimumSpeed; // Slow down, using minimumSpeed\r\n});\r\n\r\n// Accelerate player planet speed on keyup and decelerate on keydown\r\ndocument.addEventListener('keydown', (event) => {\r\n    if (event.key === 'ArrowUp') {\r\n        velocity = Math.min(velocity + 0.01, maxSpeed); // Speed up, capped at maxSpeed\r\n    } else if (event.key === 'ArrowDown') {\r\n        velocity = minimumSpeed; // Slow down, using minimumSpeed\r\n    }\r\n});\r\n\r\n// update resetGame() function to reload browser and restart game\r\nfunction resetGame() {\r\n    gameOver = false;\r\n    playerAngle = 0;\r\n    enemyAngle = Math.PI;\r\n    animate();\r\n}\r\n\r\n// Add reset listener\r\ndocument.addEventListener('keydown', (event) => {\r\n    if (event.key === 'r' || event.key === 'R') {\r\n        resetGame();\r\n        // reload browser\r\n        window.location.reload();\r\n    }\r\n});\r\n\r\ndocument.getElementById('reset').addEventListener('click', () => {\r\n    resetGame();\r\n    // reload browser\r\n    window.location.reload();\r\n});\r\n\r\n// Add event listener for mobile & tablet\r\ndocument.getElementById('accelerate').addEventListener('touchstart', () => {\r\n    velocity = Math.min(velocity + 0.01, maxSpeed); // Speed up, capped at maxSpeed\r\n});\r\n\r\n\r\n// Start the game\r\nanimate();"],"names":["scene","aspectRatio","cameraWidth","cameraHeight","camera","renderer","ambientLight","dirLight","createPlanet","color","radius","geometry","material","sphere","enemyColors","playerPlanet","enemyPlanet","createOrbitTrack","trackRadius","centerX","centerZ","outlineGeometry","points","segments","i","theta","outlineMaterial","outline","angle","offsetDistance","offsetX","offsetZ","centerAdjustX","centerAdjustZ","track1","track2","gameState","gameOver","playerAngle","velocity","maxSpeed","minimumSpeed","decelerationRate","lastUpdateTime","scorePoint","checkCollision","planet1","planet2","loopCount","animate","currentTime","deltaTime","randomColor","randomAngle","randomSpeed","newEnemyPlanet","addStars","starsGeometry","starsMaterial","starsVertices","x","y","z","stars","newAspectRatio","newCameraHeight","event","resetGame"],"mappings":"ssBAAA,OAAO,MAAK,EAGZ,MAAMA,EAAQ,IAAI,MAAM,MACxBA,EAAM,WAAa,IAAI,MAAM,MAAM,MAAQ,EAG3C,MAAMC,EAAc,OAAO,WAAa,OAAO,YACzCC,EAAc,IACdC,EAAeD,EAAcD,EAE7BG,EAAS,IAAI,MAAM,mBACrBF,EAAc,GACdA,EAAc,EACdC,EAAe,EACfA,EAAe,GACf,GACA,GACJ,EACAC,EAAO,SAAS,IAAI,EAAG,KAAM,GAAG,EAChCA,EAAO,OAAO,EAAG,EAAG,CAAC,EAGrB,MAAMC,EAAW,IAAI,MAAM,cAC3BA,EAAS,QAAQ,OAAO,WAAY,OAAO,WAAW,EACtDA,EAAS,UAAU,QAAU,GAC7B,SAAS,KAAK,YAAYA,EAAS,UAAU,EAG7C,MAAMC,EAAe,IAAI,MAAM,aAAa,OAAQ,EACpDN,EAAM,IAAIM,CAAY,EAEtB,MAAMC,EAAW,IAAI,MAAM,iBAAiB,SAAU,EAAG,EACzDA,EAAS,SAAS,IAAI,IAAK,KAAM,GAAG,EAAE,YACtCA,EAAS,WAAa,GACtBP,EAAM,IAAIO,CAAQ,EAGlB,SAASC,EAAaC,EAAQ,GAAIC,EAAS,GAAI,CAC3C,MAAMC,EAAW,IAAI,MAAM,eAAeD,EAAQ,GAAI,EAAE,EAClDE,EAAW,IAAI,MAAM,kBAAkB,CACzC,MAAOH,EACP,UAAW,EACnB,CAAK,EACKI,EAAS,IAAI,MAAM,KAAKF,EAAUC,CAAQ,EAChD,OAAAC,EAAO,WAAa,GACpBA,EAAO,cAAgB,GACvBA,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EAC3BA,EAAO,YAAc,EACdA,CACX,CAEA,MAAMC,EAAc,CAChB,SACA,SACA,QACA,SACA,QACA,SACA,SACA,SACA,QACA,QACJ,EAGMC,EAAeP,EAAa,OAAQ,EAE1C,IAAIQ,EAAcR,EAAaM,EAAY,KAAK,MAAM,KAAK,SAAWA,EAAY,MAAM,CAAC,CAAC,EAE1Fd,EAAM,IAAIe,CAAY,EACtBf,EAAM,IAAIgB,CAAW,EAGrB,SAASC,EAAiBC,EAAaT,EAAOU,EAASC,EAAS,CAC5D,MAAMC,EAAkB,IAAI,MAAM,eAC5BC,EAAS,CAAA,EACTC,EAAW,GAEjB,QAASC,EAAI,EAAGA,GAAKD,EAAUC,IAAK,CAChC,MAAMC,EAASD,EAAID,EAAY,KAAK,GAAK,EACzCD,EAAO,KACH,KAAK,IAAIG,CAAK,EAAIP,EAAcC,EAChC,EACA,KAAK,IAAIM,CAAK,EAAIP,EAAcE,CAC5C,CACK,CAEDC,EAAgB,aAAa,WAAY,IAAI,MAAM,uBAAuBC,EAAQ,CAAC,CAAC,EACpF,MAAMI,EAAkB,IAAI,MAAM,mBAAmB,CACjD,MAAOjB,EACP,SAAU,GACV,QAAS,EACjB,CAAK,EAEKkB,EAAU,IAAI,MAAM,SAASN,EAAiBK,CAAe,EACnE,OAAAC,EAAQ,qBAAoB,EACrBA,CACX,CAGA,IAAIC,EAAQ,KAAO,KAAK,GAAK,KAE7B,MAAMC,EAAiB,IACjBC,EAAU,KAAK,IAAIF,CAAK,EAAIC,EAC5BE,EAAU,KAAK,IAAIH,CAAK,EAAIC,EAE5BG,EAAgB,CAACF,EAAU,EAC3BG,EAAgB,CAACF,EAAU,EAE3BG,EAASjB,EAAiB,IAAK,QAAUe,EAAeC,CAAa,EACrEE,EAASlB,EAAiB,IAAK,QAAUa,EAAUE,EAAeD,EAAUE,CAAa,EAG/FjC,EAAM,IAAIkC,CAAM,EAChBlC,EAAM,IAAImC,CAAM,EAGhB,MAAMC,EAAY,CACd,QAAS,GACT,cAAe,KACf,iBAAkB,EAClB,mBAAoB,EACpB,MAAO,EACP,cAAe,EACf,aAAc,CAAE,EAChB,SAAU,CACN,WAAY,GACZ,WAAY,EACf,CACL,EAEAA,EAAU,aAAa,KAAK,CACxB,KAAMpB,EACN,MAAO,KAAK,GACZ,MAAO,KACP,OAAQ,IACR,UAAW,EACf,CAAC,EAGD,IAAIqB,EAAW,GACXC,EAAc,EAGdC,EAAW,KACf,MAAMC,EAAW,MACXC,EAAe,OACfC,EAAmB,MACzB,IAAIC,EAAiB,YAAY,MAGjC,SAASC,GAAa,CAClBR,EAAU,OAAS,EACnB,SAAS,eAAe,OAAO,EAAE,UAAYA,EAAU,MAEvD,QAAQ,IAAI,UAAYA,EAAU,KAAK,CAC3C,CAGA,SAASS,EAAeC,EAASC,EAAS,CAEtC,OADiBD,EAAQ,SAAS,WAAWC,EAAQ,QAAQ,EAC3C,EACtB,CAGA,IAAIC,EAAY,EAEhB,SAASC,GAAU,CACf,GAAIZ,EAAU,OACd,sBAAsBY,CAAO,EAE7B,MAAMC,EAAc,YAAY,MAC1BC,GAAaD,EAAcP,GAAkB,IACnDA,EAAiBO,EAGbX,EAAW,EACXA,EAAW,KAAK,IAAIA,EAAWG,EAAmBS,EAAW,CAAC,EACvDZ,EAAW,IAClBA,EAAW,KAAK,IAAIA,EAAWG,EAAmBS,EAAW,CAAC,GAIlE,MAAMjC,EAAc,IAcpB,GAXAoB,GAAeC,EACfxB,EAAa,SAAS,EAAI,KAAK,IAAIuB,CAAW,EAAIpB,EAAcc,EAChEjB,EAAa,SAAS,EAAI,KAAK,IAAIuB,CAAW,EAAIpB,EAAce,EAG5DM,IAAa,IACbD,GAAeG,EACf1B,EAAa,SAAS,EAAI,KAAK,IAAIuB,CAAW,EAAIpB,EAAcc,EAChEjB,EAAa,SAAS,EAAI,KAAK,IAAIuB,CAAW,EAAIpB,EAAce,GAGhEK,GAAe,KAAK,GAAK,IACzBA,GAAe,KAAK,GAAK,EACzBU,IAEIA,EAAY,IAAM,GAClBJ,IAIAI,EAAY,IAAM,GAAG,CACrB,MAAMI,EAActC,EAAY,KAAK,MAAM,KAAK,SAAWA,EAAY,MAAM,CAAC,EACxEuC,EAAc,KAAK,OAAQ,EAAG,KAAK,GAAK,EACxCC,EAAc,IAAO,KAAK,OAAM,EAAK,IAErCC,EAAiB/C,EAAa4C,EAAa,KAAK,SAAW,GAAK,EAAE,EACxEG,EAAe,SAAS,EAAI,KAAK,IAAIF,CAAW,EAAInC,GAAeY,EAAUE,GAC7EuB,EAAe,SAAS,EAAI,KAAK,IAAIF,CAAW,EAAInC,GAAea,EAAUE,GAE7EjC,EAAM,IAAIuD,CAAc,EAGxBnB,EAAU,aAAa,KAAK,CACxB,KAAMmB,EACN,MAAOF,EACP,MAAOC,EACP,UAAW,EAC3B,CAAa,CACJ,CAILlB,EAAU,aAAa,QAASpB,GAAgB,CAM5C,GALAA,EAAY,OAASA,EAAY,OAASA,EAAY,UAAY,GAClEA,EAAY,KAAK,SAAS,EAAI,KAAK,IAAIA,EAAY,KAAK,EAAIE,GAAeY,EAAUE,GACrFhB,EAAY,KAAK,SAAS,EAAI,KAAK,IAAIA,EAAY,KAAK,EAAIE,GAAea,EAAUE,GAGjFY,EAAe9B,EAAcC,EAAY,IAAI,EAAG,CAChDqB,EAAW,GACX,MACI,4CAA4CD,EAAU,KAAK,qDAC3E,EACY,MACH,CACT,CAAK,EAED/B,EAAS,OAAOL,EAAOI,CAAM,CACjC,CAGA,SAASoD,GAAW,CAChB,MAAMC,EAAgB,IAAI,MAAM,eAC1BC,EAAgB,IAAI,MAAM,eAAe,CAC3C,MAAO,SACP,KAAM,EACN,gBAAiB,EACzB,CAAK,EAEKC,EAAgB,CAAA,EACtB,QAASnC,EAAI,EAAGA,EAAI,IAAMA,IAAK,CAC3B,MAAMoC,GAAK,KAAK,OAAM,EAAK,IAAO,IAC5BC,GAAK,KAAK,OAAM,EAAK,IAAO,IAC5BC,GAAK,KAAK,OAAM,EAAK,IAAO,IAClCH,EAAc,KAAKC,EAAGC,EAAGC,CAAC,CAC7B,CAEDL,EAAc,aAAa,WACvB,IAAI,MAAM,uBAAuBE,EAAe,CAAC,CAAC,EAEtD,MAAMI,EAAQ,IAAI,MAAM,OAAON,EAAeC,CAAa,EAC3D1D,EAAM,IAAI+D,CAAK,CACnB,CACAP,IAGA,OAAO,iBAAiB,SAAU,IAAM,CACpC,MAAMQ,EAAiB,OAAO,WAAa,OAAO,YAC5CC,EAAkB/D,EAAc8D,EAEtC5D,EAAO,IAAM6D,EAAkB,EAC/B7D,EAAO,OAAS,CAAC6D,EAAkB,EACnC7D,EAAO,uBAAsB,EAE7BC,EAAS,QAAQ,OAAO,WAAY,OAAO,WAAW,CAC1D,CAAC,EAGD,SAAS,eAAe,YAAY,EAAE,iBAAiB,QAAS,IAAM,CAClEkC,EAAW,KAAK,IAAIA,EAAW,IAAMC,CAAQ,CACjD,CAAC,EAGD,SAAS,eAAe,YAAY,EAAE,iBAAiB,QAAS,IAAM,CAClED,EAAWE,CACf,CAAC,EAGD,SAAS,iBAAiB,UAAYyB,GAAU,CACxCA,EAAM,MAAQ,UACd3B,EAAW,KAAK,IAAIA,EAAW,IAAMC,CAAQ,EACtC0B,EAAM,MAAQ,cACrB3B,EAAWE,EAEnB,CAAC,EAGD,SAAS0B,GAAY,CACjB9B,EAAW,GACXC,EAAc,EAEdW,GACJ,CAGA,SAAS,iBAAiB,UAAYiB,GAAU,EACxCA,EAAM,MAAQ,KAAOA,EAAM,MAAQ,OACnCC,IAEA,OAAO,SAAS,SAExB,CAAC,EAED,SAAS,eAAe,OAAO,EAAE,iBAAiB,QAAS,IAAM,CAC7DA,IAEA,OAAO,SAAS,QACpB,CAAC,EAGD,SAAS,eAAe,YAAY,EAAE,iBAAiB,aAAc,IAAM,CACvE5B,EAAW,KAAK,IAAIA,EAAW,IAAMC,CAAQ,CACjD,CAAC,EAIDS,EAAS"}